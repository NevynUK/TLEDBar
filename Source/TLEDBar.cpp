//
//  This file implements the LED bar type control.
//
//  Author: Mark Stevens
//  Date: 9th April 1998
//
//  Revision history:
//      1.0     First release of the control.
//      1.01    Added the ability for the user to specify the percentage mark at
//              which the colour change occurs.
//              Modified the drawing algorithm to only draw whole bars.
//
#include <vcl.h>
#pragma hdrstop

#include "LEDBar.h"
#pragma package(smart_init)
//---------------------------------------------------------------------------
//
//  The two functions in this section are generated by C++ Builder when a control
//  module is created.
//
// ValidCtrCheck is used to assure that the components created do not have
// any pure virtual functions.
//

static inline void ValidCtrCheck(TLEDBar *)
{
    new TLEDBar(NULL);
}

namespace Ledbar
{
    void __fastcall PACKAGE Register()
    {
        TComponentClass classes[1] = {__classid(TLEDBar)};
        RegisterComponents("Samples", classes, 0);
    }
}

//-----------------------------------------------------------------------------
//
//  Constructor for the control.
//
__fastcall TLEDBar::TLEDBar(TComponent* Owner) : TCustomControl(Owner)
{
    Parent = (TWinControl *) Owner;
    minimum = 0;
    maximum = 100;
    bar_height = 4;
    orientation = orVertical;
    lower_colour = clLime;
    upper_colour = clRed;
    colour_change = 75;
    background_colour = clBtnFace;
    value = 100;
    Height = 100;
    Width = 30;
}

//-----------------------------------------------------------------------------
//
//  The following functions make up the group of functions required to set the
//  values of the published properties.
//
void __fastcall TLEDBar::SetBarHeight(int value)
{
    if (value <= 4)
        return;
    bar_height = value;
    Paint();
}

void __fastcall TLEDBar::SetLowerColour(TColor value)
{
    lower_colour = value;
    Paint();
}

void __fastcall TLEDBar::SetBackgroundColour(TColor value)
{
    background_colour = value;
    Paint();
}

void __fastcall TLEDBar::SetUpperColour(TColor value)
{
    upper_colour = value;
    Paint();
}

void __fastcall TLEDBar::SetColourChange(int value)
{
    if ((value <= 0) || (value >= 100))
        return;
    colour_change = value;
    Paint();
}

void __fastcall TLEDBar::SetOrientation(enum orient_type value)
{
    orientation = value;
    Paint();
}

void __fastcall TLEDBar::SetMinimum(int val)
{
    minimum = val;
    if (value < minimum)
        value = minimum;
    Paint();
}

void __fastcall TLEDBar::SetMaximum(int val)
{
    maximum = val;
    if (maximum > val)
        value = maximum;
    Paint();
}

void __fastcall TLEDBar::SetValue(int val)
{
    if ((val < minimum) || (val > maximum))
        return;
    value = val;
    Paint();
}

//-----------------------------------------------------------------------------
//
//  The following functions implement the actual functionality of the class.
//
void __fastcall TLEDBar::Paint()
{
    int     range, remainder, control_size, no_bars, length, led_size;
    int     bar, actual_length;
    double  percentile, val, bar_amount;
    TRect   rectangle;

    //
    //  Check the boundary conditions and the current status of the control.
    //    
    if (!Visible)
        return;
    if (maximum < minimum)
        return;
    if (orientation == orVertical)
        control_size = Height;
      else
        control_size = Width;
    if (control_size <= (2 * border_size))
        return;
    //
    //  Work out how the control should appear on the screen.
    //
    range = maximum - minimum;
    percentile = double(range) * (double(colour_change) / 100);
    length = control_size - (2 * border_size);
    length += spacer_size;
    led_size = bar_height + spacer_size;
    no_bars = int(length / led_size);
    actual_length = no_bars * led_size;
    remainder = length - actual_length;
    bar_amount = double(range) / double(no_bars);
    percentile = double(range) * (double(colour_change) / 100);
    //
    //  Now set up the display properties.
    //
    if (orientation == orVertical)
        {
        rectangle.Bottom = ClientRect.Bottom - border_size - (remainder / 2);
        rectangle.Left = ClientRect.Left + border_size;
        rectangle.Right = ClientRect.Right - border_size;
        rectangle.Top = rectangle.Bottom - bar_height;
        }
      else
        {
        rectangle.Bottom = ClientRect.Bottom - border_size;
        rectangle.Left = ClientRect.Left + border_size + (remainder / 2);
        rectangle.Right = rectangle.Left + bar_height;
        rectangle.Top = ClientRect.Top + border_size;    
        } 
    //
    //  Display the control on the screen.
    //
    Canvas->Brush->Style = bsSolid;
    Canvas->Brush->Color = background_colour;
    Canvas->FillRect(ClientRect);
    for (bar = 0; bar < no_bars; bar++)
        {
        val = (bar + 1) * bar_amount;
        if (val <= value)
            {
            if (val <= double(percentile))
                Canvas->Brush->Color = lower_colour;
              else
                Canvas->Brush->Color = upper_colour;
            Canvas->FillRect(rectangle);
            if (orientation == orVertical)
                {
                rectangle.Bottom -= led_size;
                rectangle.Top -= led_size;
                }
              else
                {
                rectangle.Left += led_size;
                rectangle.Right += led_size;
                }
            }
        }
}
